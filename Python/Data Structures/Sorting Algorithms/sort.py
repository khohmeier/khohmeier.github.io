import random
import time

# NOTE: Portions of this code were generated by consulting the textbook as reference and also via note-taking in class.


def bubble_sort(alist):
    """
    Implementation of the bubble sort sorting method

    Parameter:
        alist: a list of numbers

    Return:
         the sorted list
    """
    for i in range(len(alist)):  # this loops sends the biggest element to the back of the list
        for j in range(len(alist)-1):
            if alist[j] > alist[j+1]:  # items out of order
                temp = alist[j]
                alist[j] = alist[j+1]
                alist[j+1] = temp
    return alist


def selection_sort(alist):
    """
    Implementation of selection sort sorting method

    Parameter:
        alist: a list of numbers

    Return:
        the sorted list
    """
    for slot in range(len(alist) - 1, 0, -1):
        max_pos = 0
        for location in range(1, slot + 1):
            if alist[location] > alist[max_pos]:
                max_pos = location

        temp = alist[slot]
        alist[slot] = alist[max_pos]
        alist[max_pos] = temp

    return alist


def insertion_sort(alist):
    """
    Implementation of insertion sort sorting method

    Parameter:
        alist: a list of numbers

    Return:
         the sorted list
    """
    for i in range(1, len(alist)):
        current = alist[i]
        pos = i
        while pos > 0 and alist[i-1] > current:
            alist[pos] = alist[pos - 1]
            pos = pos - 1

        alist[pos] = current

    return alist


# First quicksort - not using extra lists and extra space

def quicksort(alist):  # non-recursive implementation of quicksort
    """
    First implementation of quicksort: does not use extra space.

    Parameters:
        alist: a list of numbers

    Return:
        the sorted list
    """
    quickSortHelper(alist, 0, len(alist) - 1)
    return alist


def quickSortHelper(alist, first, last):
    """
    A recursive helper function for the quicksort function

    Parameters:
        alist: a list of numbers
        first: the first index point
        last: the last index point

    Return:
        None
    """
    if first < last:
        split = partition(alist, first, last)

        quickSortHelper(alist, first, split - 1)
        quickSortHelper(alist, split + 1, last)


def partition(alist, first, last):
    """
    A partition function that locates a split point and moves data in the list based on whether it is larger or smaller
    than a pivot value

    Parameters:
        alist:
        first:
        last:

    Return:
        The right mark, which at the completion of the partition function will be the new split point
    """
    pivot = alist[first]

    left = first + 1
    right = last

    done = False
    while not done:

        while left <= right and alist[left] <= pivot:
            left = left + 1

        while alist[right] >= pivot and right >= left:
            right = right - 1

        if right < left:
            done = True
        else:
            temp = alist[left]
            alist[left] = alist[right]
            alist[right] = temp

    temp = alist[first]
    alist[first] = alist[right]
    alist[right] = temp

    return right


# Second quicksort - using extra lists to store low and high values

def qsort(alist):  # recursive implementation of quicksort
    """
    Recursive implementation of quicksort sorting method

    Parameter:
        alist: a list of numbers

    Return:
        a recursive call to the qsort function. Ultimately, it will return the sorted list.
    """
    if alist == []:
        return []
    else:
        pivot = alist[0]
        low, high = partition_new(pivot, alist[1:])
        return qsort(low) + [pivot] + qsort(high)


def partition_new(pivot, alist):
    """
    A partition function that stores "low" and "high" values in

    Parameters:
        pivot: the pivot point around which the "low" and "high" lists are created
        alist: a list of numbers

    Return:
        two lists - one containing all the numbers less than the pivot, and another containing all the numbers greater
        than the pivot
    """
    low = []
    high = []

    for value in alist:
        if value <= pivot:
            low.append(value)
        else:
            high.append(value)

    return low, high


#####
#####
#measure execution time of passed function
def time_this(function, *args):
    start = time.clock()  #record initial time
    result = function(*args)  # perform the task
    end = time.clock()  #record final time
    return end-start  # return difference 


# return a list of length size filled with random ints in
# the range low-->high
def random_list(size, low, high):
    random.seed()
    a = [random.randint(low, high) for r in range(size)]

    return a


def test_sort(function):
    func_name = str(function).split()[1]
    print("Testing ", func_name)
    
    size = int(input("Enter list size: "))

    total_effort = 0
    num_trials = 20
    for r in range(num_trials):
        #generate a new random list of numbers of given size
        alist = random_list(size, 0, 1000000)

        elapsed_time = time_this(function, alist)
        total_effort += elapsed_time
        
        print(func_name,":",size,";Completed in ",elapsed_time)
        

    print(func_name,":size =",size,":num_trials =",num_trials,":Average time = ", format(total_effort/num_trials,".8f"))


test_sort(bubble_sort)
test_sort(selection_sort)
test_sort(insertion_sort)
test_sort(quicksort)
test_sort(qsort)
